language ferrum/test/0.1


[ 

  [ ["name", "power1"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
    let power : { Int -> Int -> Int } = 
      fix <| (power : { Int -> Int -> Int }) -> (n : Int) -> (x : Int) ->
      if (n == 0)
      [ -> 1
      , -> power (n - 1) x * x
      ];

    let cube = power <$ 3;   
    -- let cube = power <| 3;   

  """
  ]
  , ["expectTerm", "cube", "x -> 1 * x * x * x"]
  , ["expectValue", "cube 5", "125"]
  , ["expectValue", "(power <$ 3) 5", "125"]
  ]


, [ ["name", "power2"]
  , ["language", "ferrum/0.1"]
  , ["primitives", "../fe/primitives/vso.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
  """
    let flip = 
      (f : F @ { Void -> Void -> Any }) -> 
      (x : X @ (Domain (Codomain F))) -> 
      (y : Y @ (Domain F)) -> 
      f y x;

    let power : { Int -> Int -> Int } = 
      (x : Int) ->
      -- fix <| (pow : { Int -> Int }) -> 
      fix2 <| (pow : { Int -> Int }) -> 
      (n : Int) -> 
      if (n == 0)
      [ -> 1
      , -> n $? pow (n - 1) * x
      ];

    let cube = (flip power) <$ 3;   
    -- let cube = (flip power) <| 3;   

    let two_raised_a = power <| 2;  
    let two_raised_b = power <$ 2;  

    let two_raised_a_5 = two_raised_a 5;  
    let two_raised_b_5 = two_raised_b 5;  

  """
  ]
  , ["expectValue", "cube 5", "125"]
  , ["expectValue", "(power <$ 5) 3", "125"]
  , ["expectValue", "(flip power <$ 3) 5", "125"]
  , ["expectTerm", "cube", "x -> 1 * x * x * x"]

  , ["expectTerm", "two_raised_a_5", "32"]
  , ["expectTerm", "two_raised_b_5", "32"]
  , ["expectValue", "two_raised_b 5", "32"]

  , ["expectTerm", "two_raised_b", 
      """
        let raise = 
            f -> n -> 
            if (n == 0) 
            [ -> 1
            , -> n $? f (n - 1) * 2
            ];

        -- n -> raise (fix raise) n 
        n -> fix2 raise n
      """
    ]

  -- If we eta-contract the result, we get this.
  , ["expectTerm", "two_raised_b", "fix2 <| f -> n -> if (n == 0) [ -> 1, -> n $? f (n - 1) * 2]"]
  -- Note "fix2" is a 2-arity primitive, it can only exist in the graph in a fully saturated form.
  -- Any under-saturated uses in the AST will be automatically eta-expanded during instantiation.
  ]



, [ ["name", "list-predicates"]
  , ["language", "ferrum/0.1"]
  , ["project", "../fe/examples/prelude.proj.fe"]
  , ["type_check", "bidir"]
  , ["decls", 
    """
      let nums : List Int = [8, 9, 10, 11];

      let a = listAllTrue nums <| n -> n > 10;
      let b = listAnyTrue nums <| n -> n > 10;

    """
    ]

  , ["expectValue", "a", "false"]
  , ["expectValue", "b", "true"]

  ]

-- , [ ["name", "tower1"]
--   , ["language", "ferrum/0.1"]
--   , ["project", "../fe/examples/tower.proj.fe"]
--   , ["type_check", "bidir"]
--   , ["decls", 
--     """
--      
--       let evalStr : { Str -> Any } =
--           input ->
--           -- debug2 ["evalStr/input", input] <| ->
--           let toks = scan input;
--           -- debug2 ["evalStr/toks", toks] <| ->
--           let ast = parseExpr toks;
--           -- debug2 ["evalStr/ast", ast] <| ->
--           let value = eval1 ast initEnv;
--           -- debug2 ["evalStr/value", value] <| ->
--           value;
-- 
-- 
--       let a = 10;
-- 
--       let addup = fix <| (addup : { Int -> Int }) -> (x : Int) -> if (x == 0) [ -> 0, -> x + addup (x - 1)];
-- 
--       let addup_src = "fix <| (addup : { Int -> Int }) -> (x : Int) -> if (x == 0) [ -> 0, -> x + addup (x - 1)]";
--       let addup2 = evalStr addup_src;
--       -- let addup2 = evalStr <$ addup_src;
--       let addup2 = addup2 |> justTrustMeCast Any { Int -> Int };
-- 
--       -- let eval_decls_toks = scanFile "eval.fe" eval_declsStr;
--       -- let eval_decls_ast = parseDecls eval_decls_toks;
--       -- let eval2_ast : Expr = ["ELets", eval_decls_ast, ["EVar", "eval1"]];
--       -- let addup_ast = parseExpr (scan addup_src);
--       -- let eval2 = eval1 eval2_ast initEnv;
--       -- -- let eval2 = eval1 eval2_ast <$ initEnv;
--       -- let eval2 = eval2 |> justTrustMeCast Any { Expr -> Env -> Any };
--       -- let addup3 = eval2 addup_ast initEnv;
--       -- let addup3 = addup3 |> justTrustMeCast Any { Int -> Int };
-- 
--     """
--     ]
-- 
--   , ["expectValue", "a", "10"]
--   , ["expectTerm", "addup", "let v0_1=(v1_ -> (v2_ -> ( if2 ( v2_ == 0 ) [([] -> 0),([] -> ( v2_ + v1_ ( v2_ - 1 ) ))] )));(v1_ -> v0_1 ( fix v0_1 ) v1_)"]
--   , ["expectValue", "addup 10", "55"]
--   , ["expectTerm", "addup2", "let v0_1=(v1_ -> (v2_ -> (  if2 ( v2_ == 0 ) [([] -> 0),([] -> ( v2_ + v1_ ( v2_ - 1 ) ))] )));(v1_ -> v0_1 ( fix v0_1 ) v1_)"]
--   , ["expectValue", "addup2 10", "55"]
--   -- , ["expectValue", "addup3 10", "55"]
-- 
--   ]


]


